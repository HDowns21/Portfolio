# -*- coding: utf-8 -*-
"""downs_harrison_a8.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1i8RueK0a34t29h1TP8K2R1nb0PRqOlBh
"""

# Harrison Downs | CSCI 6385 | a8 code - Password Strength Classifier

# NOTE: Please ensure that sample_data.csv AND common_passwords.txt are
#   downloaded. This project was originally created in Colab, so if you upload
#   these two files directly into the 'files' menu on the left, it should
#   work as intended. However, if you want to run this on your machine, please
#   download those files and adjust the filepaths as needed.

import pandas as pd
import math
import re
from collections import Counter
from sklearn.linear_model import LogisticRegression
from sklearn.model_selection import train_test_split
from sklearn.metrics import accuracy_score
from sklearn.preprocessing import StandardScaler

# Load password training set
data = pd.read_csv("/content/sample_data.csv")

# Load the common passwords list into a set for fast lookups
with open("/content/common_passwords.txt", "r") as f:
    common_passwords = set(line.strip() for line in f)


print(f"Dataset rows: {len(data)}")

# Feature extraction function
def extract_features(password):
    password = str(password).strip()
    if not password:
        return {
            "length": 0,
            "uppercase": 0,
            "lowercase": 0,
            "digits": 0,
            "special": 0,
            "entropy": 0,
            "uniqueness_ratio": 0,
            "has_common_pattern": 0,
            "common_password_flag": 0
        }

    # Length and character counts
    length = len(password)
    uppercase = sum(1 for char in password if char.isupper())
    lowercase = sum(1 for char in password if char.islower())
    digits = sum(1 for char in password if char.isdigit())
    special = sum(1 for char in password if not char.isalnum())

    # Shannon entropy
    char_counts = Counter(password)
    total_chars = sum(char_counts.values())
    entropy = -sum((count / total_chars) * math.log2(count / total_chars) for count in char_counts.values())

    # Uniqueness ratio
    uniqueness_ratio = len(char_counts) / length if length > 0 else 0

    # Detect common patterns
    # Simple regex for consecutive letters, repeated substrings, or numeric sequences
    has_common_pattern = int(
        bool(re.search(r'(.)\1{2,}', password)) or  # Repeated characters (e.g., "aaa")
        bool(re.search(r'(abc|123|password|qwerty|asdf)', password, re.IGNORECASE)) or  # Common sequences
        bool(re.search(r'(.{2,})\1', password))  # Repeated substrings (e.g., "ababab")
    )

    # Check if the password is in the common passwords list
    common_password_flag = 1 if password in common_passwords else 0

    return {
        "length": length,
        "uppercase": uppercase,
        "lowercase": lowercase,
        "digits": digits,
        "special": special,
        "entropy": entropy,
        "uniqueness_ratio": uniqueness_ratio,
        "has_common_pattern": has_common_pattern,
        "common_password_flag": common_password_flag
    }

# Apply feature extraction
features = pd.DataFrame([extract_features(pw) for pw in data['Password']])
labels = data['Strength']

# Split data
X_train, X_test, y_train, y_test = train_test_split(features, labels, test_size=0.2, random_state=7)

# Standardize features
scaler = StandardScaler()
X_train = scaler.fit_transform(X_train)
X_test = scaler.transform(X_test)

# Train model
agent = LogisticRegression(random_state=7, max_iter=1000, class_weight='balanced')
agent.fit(X_train, y_train)

# Evaluate
y_pred = agent.predict(X_test)
accuracy = accuracy_score(y_test, y_pred)
print(f"Model accuracy: {accuracy * 100:.2f}%\n")

# Define password strength function with feedback
def check_pw_strength(pw):
    # Extract features
    feature_values = extract_features(pw)
    feature_df = pd.DataFrame([feature_values])  # Create DataFrame for input
    standardized_features = scaler.transform(feature_df)  # Scale features

    # Get prediction and probabilities
    probabilities = agent.predict_proba(standardized_features)[0]
    prediction = agent.predict(standardized_features)[0]
    confidence = probabilities[prediction]  # Confidence for the predicted class

    # Feedback based on prediction and confidence
    feedback = ""
    if prediction == 0:
        feedback = (
            f"Your password is weak (confidence: {confidence * 100:.2f}%).\n"
            "Consider making it longer and adding a mix of uppercase letters, digits, and special characters.\n"
        )
    elif prediction == 1:
        feedback = (
            f"Your password is okay (confidence: {confidence * 100:.2f}%).\n"
            "Consider adding more diversity and randomness.\n"
        )
    elif prediction == 2:
        feedback = (
            f"Great! Your password is strong (confidence: {confidence * 100:.2f}%).\n"
        )
    else:
        feedback = "Invalid password strength.\n"

    feedback += (
        f"It has a length of {feature_values['length']},\n"
        f"{feature_values['uppercase']} uppercase letters,\n"
        f"{feature_values['lowercase']} lowercase letters,\n"
        f"{feature_values['digits']} digits,\n"
        f"{feature_values['special']} special characters,\n"
        f"a Shannon entropy of {feature_values['entropy']:.2f},\n"
        f"a uniqueness ratio of {feature_values['uniqueness_ratio']:.2f},\n"
        f"{'has' if feature_values['has_common_pattern'] else 'does not have'} a common pattern, and\n"
        f"{'is' if feature_values['common_password_flag'] else 'is not'} a common password.\n"
    )

    return prediction, feedback

# See feature weights of each strength category
feature_names = features.columns  # Names of the features
weights = agent.coef_  # Coefficients for each class
intercepts = agent.intercept_  # Intercepts for each class

# Display the weights for each feature
print("Feature weights for each strength category:")
for i, class_weights in enumerate(weights):
    print(f"Class {i} (Strength {i}):")
    for feature, weight in zip(feature_names, class_weights):
        print(f"  {feature}: {weight:.4f}")
    print(f"  Intercept: {intercepts[i]:.4f}\n")

# See average feature value for each strength category
for strength in range(3):
  strength_features = features[labels == strength]
  print(f"Average feature values for strength {strength}:")
  print(strength_features.mean())
  print("\n")



# Check password
continue_check = True

while continue_check:
  password = input("Password: ")
  strength, feedback = check_pw_strength(password)
  print(feedback)
  print("Continue? y/n:")
  choice = input()
  if choice.lower() == 'n':
    continue_check = False